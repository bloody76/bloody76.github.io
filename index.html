This blog post is intended to discuss some of the different standard types. It
is motivated by the fact that the C++ standard defined the type size_t
and not ssize_t. First we introduce a table that presents the differents size
of types on different architectures.

------------===------------------------------
| Arch    | int | long | long long | size_t |
=============================================
| win32   | 4   |  4   |   8       |    4   |
| win64   | 4   |  4   |   8       |    8   |
| linux32 | 4   |  4   |   8       |    4   |
| linux64 | 4   |  8   |   8       |    8   |
=============================================

size_t
======

The std::size_t standard type is an unsigned integral type. It usually
represents sizes and counts and is always defined as the type returned by
the sizeof keyword.

The particularity of size_t is its size on a 32bits architecture and on a
64bits architecture. On a 32bits architecture, the size of the type size_t
will be 4 bytes whereas on a 64bits architecture it will be 8 bytes.

ssize_t
=======

The problem with ssize_t is that it's not a standard type. Also, we can see
some definitions of the ssize_t type. For example:

- libcups defines ssize_t as off_t for windows, which is a long integer.

- asm posix_types defines ssize_t as:
  - a long integer for 64bits architectures,
  - an integer for 32bits architectures.

- libusb defines ssize_t as an __int64 for 64bits architectures and as an int
for 32bits architectures.

The main problem for defining ssize_t on 64bits architectures as long is that
long is a 4 bytes type on win32 and win64 architectures. Whereas in modern
linux operating systems, long is defined as a 4 bytes type on 32bits and 8
bytes on a 64bits.

After some tests, off_t seems to be 32bits on a win32 architecture.


int_fast*_t
===========

Other types are defined in the C++ standard, the int_fast*_t types. They are:

- int_fast8_t,
- int_fast16_t,
- int_fast32_t,
- int_fast64_t.

The goal of this kind of type is to choose the type which is the faster
according to an architecture. For example, if you use int_fast32_t on a 64bits
architecture, it is highly possible that the size of this type will be 8
bytes because the alignment is on 8 bytes.

Tested on a 64bits ubuntu 13.10 with gcc-4.6.3:

--begin_code
#include <stdint.h>

int main(void)
{
  return sizeof (int_fast32_t); // Returns 8.
}
--end_code

The program returns 8. So it is for the uint_fast32_t.

From this point of view, we may see uint_fast32_t and size_t as synonyms as
they behave similarly.

int_least*_t
============

Another type defined in the C++ standard is the int_least*_t. They are:

- int_least8_t,
- int_least16_t,
- int_least32_t,
- int_least64_t.

To goal of this kind of type is to choose to type the closest to the size
demanded.

The previous program here would returns 4.

--begin_code
#include <stdint.h>

int main(void)
{
  return sizeof (int_least32_t); // Returns 4.
}
--end_code

The advantage here is to keep the size the closest to what we want, even if
the architecture changes. It is obvious here that uint_least32_t and size_t
don't behave the same way.

Performance tests
=================

Coming soon.
